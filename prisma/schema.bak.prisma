import { Router, Request, Response } from "express";
import bcrypt from "bcrypt";
import { PrismaClient, ReservationStatus } from "@prisma/client";

const prisma = new PrismaClient();
const router = Router();

/** 공통 응답 헬퍼 */
const ok = (res: Response, message: string, extra: Record<string, any> = {}) =>
  res.json({ message, ...extra });

const err = (res: Response, message: string, status = 400) =>
  res.status(status).json({ error: message });

/** (예시) 토큰에서 현재 로그인 사용자 id 추출
 *  - 실제 서비스의 인증 미들웨어/라이브러리에 맞게 교체하세요.
 */
function getUserIdFromAuth(req: Request): number | null {
  // 예: Authorization: Bearer <jwt>
  // 토큰 파싱/검증 후 payload.userId를 반환하도록 구현
  // 여기서는 예시로 req.user?.id 사용
  // @ts-ignore
  if (req.user?.id) return Number(req.user.id);
  return null;
}

/** 민감정보 제거용 셀렉트 */
const reservationSelect = {
  id: true,
  seatId: true,
  userId: true,
  startTime: true,
  endTime: true,
  endedAt: true,
  status: true,
  extended: true,
  createdAt: true,
  seat: {
    select: {
      id: true,
      room: true,
      seatNumber: true,
      label: true,
      fixed: true,
    },
  },
  user: {
    select: {
      id: true,
      studentId: true,
      userId: true,
      name: true,
      email: true,
      course: true,
      // passwordHash는 절대 내보내지 않음
    },
  },
} as const;

/**
 * POST /checkout
 * Body: { reservationId: string|number, password: string }
 * 성공: { "message": "Checkout success", "reservation": { ...updated } }
 * 실패: { "error": "설명" }
 */
router.post("/checkout", async (req: Request, res: Response) => {
  try {
    const { reservationId, password } = req.body ?? {};

    // 1) 요청 유효성
    if (!reservationId || !password) {
      return err(res, "reservationId와 password를 모두 전달해주세요.", 400);
    }

    const currentUserId = getUserIdFromAuth(req);
    if (!currentUserId) {
      return err(res, "인증이 필요합니다.", 401);
    }

    const id = Number(reservationId);
    if (Number.isNaN(id)) {
      return err(res, "reservationId 형식이 올바르지 않습니다.", 400);
    }

    // 2) 예약 존재 여부 + 유저 로드(비번 검증을 위해)
    const reservation = await prisma.reservation.findUnique({
      where: { id },
      include: { user: true }, // passwordHash 확인 필요
    });

    if (!reservation) {
      return err(res, "예약이 존재하지 않습니다.", 404);
    }

    // 3) 토큰 사용자와 예약 userId 일치 확인
    if (reservation.userId !== currentUserId) {
      return err(res, "해당 예약에 대한 권한이 없습니다.", 403);
    }

    // 4) 비밀번호 검증
    const okPassword = await bcrypt.compare(password, reservation.user.passwordHash);
    if (!okPassword) {
      // 요구사항 명시 문구
      return err(res, "비밀번호가 올바르지 않습니다.", 401);
    }

    // (선택) 이미 FINISHED/CANCELED/EXPIRED면 중복 처리 방지
    if (
      reservation.status === ReservationStatus.FINISHED ||
      reservation.status === ReservationStatus.CANCELED ||
      reservation.status === ReservationStatus.EXPIRED
    ) {
      // 이미 종료된 예약은 그대로 반환(프론트 일관성 위해 성공 응답으로 처리)
      const existing = await prisma.reservation.findUnique({
        where: { id },
        select: reservationSelect,
      });
      return ok(res, "이미 퇴실 처리된 예약입니다.", { reservation: existing });
    }

    // 5) 퇴실 처리: status=FINISHED, endedAt=now()
    const updated = await prisma.reservation.update({
      where: { id },
      data: {
        status: ReservationStatus.FINISHED,
        endedAt: new Date(),
      },
      select: reservationSelect,
    });

    // 성공 응답 예시 준수
    return ok(res, "Checkout success", { reservation: updated });
  } catch (e) {
    console.error(e);
    return err(res, "서버 오류가 발생했습니다.", 500);
  }
});

export default router;
